SMALLEST_PRIME = 2

def input_list():
    """
    a func that asks the user for a string input.
    the func will append the string into a list "a" until the input is empty
    :return: the list user_string_list
    """
    user_string_list = []
    user_string_input = input()
    while user_string_input != "":
        user_string_list.append(user_string_input)
        user_string_input = input()
    return user_string_list

def concat_list(str_list):
    """
    this func gets a list if strings, and concatenates them in to a one
    string, with spaces between them.
    :param str_list:
    :return: a concatenated string of all the strings in str_list
    """
    concat_string = ""  # concatenated string
    for s in str_list:
        concat_string += s + " "
    return concat_string[:len(concat_string)-1]

def maximum(num_list):
    """
    a func that gets a list if numbers, and return the largest one
    :param num_list: a list of numbers
    :return: the largest number in the list
    """
    if len(num_list) == 0:
        return None
    max = 0  # var to hold to maximum in the list(numbers known to be >= 0)
    for num in num_list:
        if num > max:  # id finds a larger number
            max = num  # new maximum
    return max


def cyclic(lst1, lst2):
    """
    this func gets two lists of number, and check whether or not they are
    cyclic.
    :param lst1: list of number
    :param lst2: list of number
    :return: id the two lists are cyclic - True\False.
    """
    if len(lst1) != len(lst2):  # if the length of the lists is different
        # then they cant be cyclic
        return False

    if len(lst1) == 0:  # here we already know both of the lists have the
        # same length, and if one of them is empty(len=0) then they are
        # both empty - 2 empty lists are cyclic.
        return True
    for num1 in range(len(lst1)):  # num1 = number is lst1
        for num2 in range(len(lst2)):  # num2 = number is lst2
            counter = 0  # number of set of same number in lists
            if lst1[num1] == lst2[num2]:  # checks to find two identical
                # numbers in the lists(not necessarily in the same index).
                counter = 1  # found one set.
                for running_index in range(1, len(lst1)):  # if we do find
 # identical numbers, then we need to run a loop len(lst) times, to check
 # all the the following numbers to be identical
                    if (lst1[(num1 + running_index) % len(lst1)] ==
                            lst2[(num2 + running_index) % len(lst2)]):
# since we already found 1 set of identical numbers, and running_index is
# set to be 0  at the beginning of the loop - we need to set the next check
# to be on running_index + 1. - also to warp the checking around the end
# of the list to the beginning, we need to divide by % len(lst)
                        counter += 1  # found another set.
                        if counter == len(lst1):  # if we found len(lst)
# times of identical sets, that means the two lists are cyclic!
                            return True
                    else:  # if not.. then run different sets of numbers in
                        # the lists..
                        counter = 0  # and of course reset counter!
                        continue

    return False  # if we never found en(lst) times of identical sets, that
    #  means the two lists aren't  cyclic..

def seven_boom(n):
    """
    makes a list of the game 7 boom until a number n.
    if the number divided by 7, or has the number 7 in it, them put "boom"
    in the list - otherwise, put the number in the list
    :param n: number to play 7 boom.
    :return: the list generated by the game
    """
    boom_list = []  # list to contain the result of the game
    for num in range(1, n+1):  # run the game from 1 to n(including n)
        if(num % 7 == 0) or ("7" in str(num)):  # the rules of 7 boom
            boom_list.append("boom")  # add to the list
        else:  # just a normal number not containing or divisible by 7
            boom_list.append(str(num))  # add to the list
    return boom_list  # return the generated list


def histogram(n, num_list):
    """
    func gets a number n, and a list of numbers, and generates a histogram.
    :param n: length of histogram
    :param num_list: list to generate histogram from
    :return: the generated histogram
    """
    generated_list_histogram = [0] * n  # initialize the list with values 0
    for list_item in num_list:
        generated_list_histogram[list_item] += 1  # the index of
        #  the number is the counter of that number
    return generated_list_histogram

def is_it_prime(n):
    """
    func that tells you if a number is prime
    :param n: number to check if prime
    :return: true\ false regarding if it is prime
    """
    if n == 1: # not a prime
        return False
    if n == SMALLEST_PRIME:  # 2 is prime, but will fail the following testing
        return True
    if n % 2 == 0:  # divisible by 2 is not prime
        return False
    for i in range(3, int(n ** 0.5) + 1, 2):  # from 3 you can start
        # checking number in intervals of 2, up to sqrt(n).
        if n % i == 0:
            return False
    return True

def prime_factors(n):
    """
    a func that given a number, will calculate all of its prime factors
    into a list
    :param n: number to generate prime factors for
    :return: a list of all prime factors of n
    """
    if n < SMALLEST_PRIME:  # no primes are less than 2
        return []
    if is_it_prime(n):
        return [n]  # if a number is prime, then it has only 1 prime factor
        # - itself.

    prime_factors_list = []  # a list to contain the prime factor
    temp_num = n  # number to check against - the latest division of n by the
    #  prime.
    for running_number_check in range(2, temp_num):  # to check only until to
        # latest division of n. running from 2, bc that's the first prime.
        if is_it_prime(running_number_check):
            while temp_num % running_number_check == 0:  # temp_num is
                # prime  and divisible by i
                prime_factors_list.append(running_number_check)# add that num
                temp_num = temp_num / running_number_check  # new number to
                #  check against should be divided by the prime we found.
                if temp_num == 1:  # if the number to check has been divided
                    #  by itself that means that was the last number to
                    # check!
                    break
    return prime_factors_list



def cartesian(lst1, lst2):
    """
    a func that given two lists, generates a list of their cartesian
    multiplication
    :param lst1: list 1 to multiply
    :param lst2: list 2 to multiply
    :return: list of the cartesian multiplication of lst1 and lst2
    """
    if len(lst1) == 0 or len(lst2) == 0:  # if one of the lists is empty,
        # then the generated list will be empty too.
        return []
    cartesian_list = []  # the list to fill with the resulting multiplication
    for object1 in lst1:
        for object2 in lst2:  # nested loop to check all of the lists against
            # each other
            cartesian_list.append([object1, object2])  # append one of each
            #  list together
    return cartesian_list



def pairs(num_list, n):
    """
    a func that checks every pair of number in a list against a number n,
    and creates a new list containing the paris that sum uo to n.
    :param num_list: list go check the pairs from
    :param n: number to check the pairs against
    :return: list of pairs who's sum is n
    """
    couples = []  # list to contain the pairs
    for num1 in range(len(num_list)):
        for num2 in range(len(num_list)-1, 0, -1):  # nested loop to run from
            # the beginning and from the end(that's why its -1) of the list,
            # until the loops "meet" and then(to avoid duplicates) the loop
            # breaks, and can stop testing, because it has went through
            # the entire list - from each end, and has "met".
            if num_list[num1] + num_list[num2] == n:  # the condition of the
                #  generated list
                couples.append([num_list[num1], num_list[num2]])
            elif num1 == num2:  # the two loops "meet"
                break
    return couples